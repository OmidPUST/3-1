Bisection method 
#include <stdio.h> 
#include <math.h> 
double f(double x) {
return x*x - x -6; // Example: x^3 -x -6
}
int main() { double a; double b; double tolerance = 1e-6; while(1){ printf("Enter 
the initial interval: "); scanf("%lf%lf", &a, &b); if (f(a) * f(b) >= 0) { 
printf("Initial interval [%.3lf, %.3lf] does not satisfy the conditions of the
bisection method.\n", a, b);
}
else{
printf("The root exists between [%lf, %lf]\n", a, b); 
break;}
}
int max_iterations = 100; for (int i = 
0; i < max_iterations; i++) {
double c = (a + b) / 2.0; double fc = f(c); if 
(fabs(fc) < tolerance || (b - a) / 2.0 < tolerance) { 
printf("Root found: %.3lf\n", c); printf("Total 
iterations: %d\n", i+1); break;
}
if (f(a) * fc < 0) {
b = c;
} else { a 
= c; }} return 
0;
}
Newton Raphson method 
#include <stdio.h> 
#include <math.h> 
double f(double x) {
return x*x - x -6; // Example: x^3 -x -6
}
double df(double x) {
return 2*x - 1;
1.
}
int main() {
double x0; printf("Enter initial guess: 
"); scanf("%lf", &x0); double 
tolerance = .0001; double x = x0; int 
max_iterations = 100; for (int i = 0; i 
< max_iterations; i++) {
double fx = f(x); double 
dfx = df(x); if (fabs(dfx) < 
tolerance) {
printf("Derivative is close to zero. Exiting...\n"); 
break;
}
double x_new = x - fx / dfx; if 
(fabs(x_new - x) < tolerance) { 
printf("Root found: %lf\n", x_new); 
printf("Total iterations: %d\n", i); 
break;
}
x = x_new;
}
return 0;
}
Regular Falsi method 
#include <stdio.h> 
#include <math.h> 
double f(double x) {
return x * x - 4; // Example: x^2 - 4}
int main() { double a; double b; double tolerance = 1e-6; while(1){ printf("Enter 
the initial interval: "); scanf("%lf%lf", &a, &b); if (f(a) * f(b) >= 0) { 
printf("Initial interval [%.3lf, %.3lf] does not satisfy the conditions of the
regular falsi method.\n", a, b);
}
else{ printf("The root exists between [%.3lf, %.3lf]\n", a, 
b); break;
}
}
2.
int max_iterations = 100; for (int i = 
0; i < max_iterations; i++) {
double fa = f(a); double fb = f(b); double c = (a * 
fb - b * fa)/(fb - fa); double fc = f(c); if (fabs(fc) < 
tolerance || (b - a) / 2.0 < tolerance) { printf("Root 
found: %.3lf\n", c); break;}
if (fa * fc < 0) { 
b = c; }
else { a = c; }}
return 0;
}
Jacobi Iteration method 
#include <stdio.h> 
#include <math.h>
int main() {
int N; printf("Enter the number of unknowns: "); 
scanf("%d", &N); double A[N][N], b[N], x[N]; 
printf("Enter the coeffients of the 
unknowns:\n"); for(int i = 0; i < N; i++){
for (int j = 0; j < N; j++){ scanf("%lf", &A[i][j]);} }
printf("Enter the constants of the equations: 
"); for(int i = 0; i < N; i++){ scanf("%lf", &b[i]); } 
printf("Enter the initial guess: "); for(int i = 0; i 
< N; i++){ scanf("%lf", &x[i]); } int 
max_iterations = 100; double tolerance = 1e6; for (int iter = 0; iter < max_iterations; iter++) 
{
double new_x[N]; for (int i 
= 0; i < N; i++) { double 
sum = 0; for (int j = 0; j < 
N; j++) {
if (j != i) { sum += A[i][j] * x[j];} }
new_x[i] = (b[i] - sum) / A[i][i];}
double error = 0; for (int i = 0; i 
< N; i++) { error += 
fabs(new_x[i] - x[i]);}
for (int i = 0; i < N; i++) {
3.
x[i] = new_x[i];}
if (error < tolerance) {break; } } 
printf("Solution:\n");
for (int i = 0; i < N; i++) {
printf("x[%d] = %lf\n", i, x[i]); }
return 0;
}
Gauss Seidal method 
#include <stdio.h> 
#include <math.h>
int main() {
int N, max_iterations = 100, iter; printf("Enter 
the number of unknowns: "); scanf("%d", &N); 
double A[N][N], b[N], x[N], tolerance = 1e-6; 
printf("Enter the coeffients of the 
unknowns:\n"); for(int i = 0; i < N; i++){
for (int j = 0; j < N; j++){ scanf("%lf", &A[i][j]); } }
printf("Enter the constants of the equations: 
"); for(int i = 0; i < N; i++){ scanf("%lf", &b[i]); } 
printf("Enter the initial guess: "); for(int i = 0; i 
< N; i++){ scanf("%lf", &x[i]); } for (iter = 0; iter 
< max_iterations; iter++) {
for (int i = 0; i < N; i++) {
double sum = 0; for (int j = 0; j < N; j++) { if (j != i) { sum 
+= A[i][j] * x[j]; } } x[i] = (b[i] - sum) / A[i][i];
}
double error = 0; for (int i = 0; i < N; i++) { error 
+= fabs(x[i] - x[i]); } if (error < tolerance) { break; 
}
} 
printf("Solution:\n");
for (int i = 0; i < N; i++) {
printf("x[%d] = %lf\n", i, x[i]); 
printf("\n");
} printf("Total iterations: %d\n", 
iter);
4.
return 0;
}
Interpolation A. Newton Forward method 
#include<stdio.h>
#include<math.h> 
#include<stdlib.h>
int main(){ float x[20], y[20], f, s, h, d, p; int i, j, n; 
printf("How many records you want to insert: 
"); scanf("%d", &n); printf("Enter the elements 
of x: "); for(i=1; i<=n; i++){ scanf("%f", &x[i]);
}
printf("Enter the elements of y: 
"); for(i=1; i<=n; i++){ scanf("%f", 
&y[i]);
}
h = x[2] - x[1]; printf("Enter the value of x for 
calculation: "); scanf("%f", &f);
s = (f-x[1])/h;
p = 1;
d = y[1]; for(i=1; i<=n-1; 
i++){ for(j=1; j<=n-i; j++){ 
y[j] = y[j+1]-y[j];
}
p = p*(s-i+1)/i; 
d = d+p*y[1];
}
printf("For the value of x = %f, the value is: %f\n", f, d); 
return 0;
}
B. Newton Backward method 
#include<stdio.h>
#include<math.h> 
#include<stdlib.h>
int main(){
float x[20], y[20], f, s, h, d, p; int i, j, k, n; 
printf("How many records you want to insert: 
"); scanf("%d", &n); printf("Enter the elements 
of x: "); for(i=1; i<=n; i++){ scanf("%f", &x[i]);
}
printf("Enter the elements of y: 
"); for(i=1; i<=n; i++){ scanf("%f", 
&y[i]);
}
h = x[2] - x[1]; printf("Enter the value of x for 
calculation: "); scanf("%f", &f);
s = (f-x[n])/h;
p = 1;
d = y[n];
for(i=n, k=1; i>=1 && k<n; k++, i--
){ for(j=n; j>=1; j--){ y[j] = y[j] 
- y[j-1];
}
p = p*(s+k-1)/k; 
d = d+p*y[n];
}
printf("For the value of x = %f, the value is: %f\n", f, d); 
return 0;
}
7.
Trapezoidal method 
#include <stdio.h> 
#include <math.h>
double f(double x) {
return 1/(1+x*x); // Example: x^2
}
double trapezoidal_rule(double a, double b, int n) {
double h = (b - a) / n; double 
sum = 0.5 * (f(a) + f(b));
for (int i = 1; i < n; i++) {
double x = a + i * h; 
sum += f(x);
}
return h * sum;
}
int main() { double a, b; int n; printf("Enter the 
lower limit of integration: "); scanf("%lf", &a); 
printf("Enter the higher limit of integration: "); 
scanf("%lf", &b); printf("Enter the number of 
subintervals: "); scanf("%d", &n); double 
result = trapezoidal_rule(a, b, n); 
printf("Approximate integral: %lf\n", result); 
return 0;
}
⅓ method 
#include <stdio.h> 
#include <math.h>
double f(double x) {
8.
return x * x; // Example: x^2
}
double simpsons_rule(double a, double b, int n) {
double h = (b - a) / n; 
double sum = f(a) + f(b); 
for (int i = 1; i < n; i++) {
double x = a + i * h; 
if (i % 2 == 0) {
sum += 2 * f(x);
} else { sum += 4 
* f(x);
}
}
return (h / 3) * sum;
}
int main() {
double a = 
0.0; double b 
= 1.0; int n = 
4; if (n % 2 != 
0) {
printf("Number of subintervals must be even.\n"); 
return 1;
}
double result = simpsons_rule(a, b, n); 
printf("Approximate integral: %lf\n", result); 
return 0;
}
⅜ method 
#include <stdio.h> 
#include <math.h>
9.
double f(double x) {
return x * x; // Example: x^2
}
double simpsons_three_eighth_rule(double a, double b, int n) {
double h = (b - a) / n; 
double sum = f(a) + f(b); 
for (int i = 1; i < n; i++) {
double x = a + i * h; 
if (i % 3 == 0) {
sum += 2 * f(x);
} else { sum += 3 
* f(x);
}
}
return (3 * h / 8) * sum;
}
int main() {
double a = 
0.0; double b 
= 1.0; int n = 
6; if (n % 3 != 
0) {
printf("Number of subintervals must be a multiple of 3.\n"); 
return 1;
}
double result = simpsons_three_eighth_rule(a, b, 
n); printf("Approximate integral: %lf\n", result); 
return 0;
}
Runge-Kutta method 
#include <stdio.h>
double f(double x, double y) {
10.
return x + y;
}
double runge_kutta(double x0, double y0, double h, double x_target) {
double x = x0; 
double y = y0; while 
(x < x_target) {
double k1 = h * f(x, y); double k2 = h 
* f(x + h / 2, y + k1 / 2); double k3 = 
h * f(x + h / 2, y + k2 / 2); double k4 
= h * f(x + h, y + k3); y = y + (k1 + 2 * 
k2 + 2 * k3 + k4) / 6; x = x + h;
}
return y;
}
int main() {
double x0, y0, h, x_target; printf("Enter Initial 
value of x0 and y0: "); scanf("%lf%lf", &x0, 
&y0); printf("Enter the value of h: "); 
scanf("%lf", &h); printf("Enter the value of 
x_target: "); scanf("%lf", &x_target); double 
result = runge_kutta(x0, y0, h, x_target); 
printf("y(%.2lf) = %.5lf\n", x_target, result); 
return 0;
}
Straight line fitting 
#include <stdio.h>
void linear_regression(double x[], double y[], int n, double *slope, double
*y_intercept) {
double sum_x = 0.0, sum_y = 0.0, sum_xy = 0.0, sum_x_squared = 0.0; 
for (int i = 0; i < n; i++) {
11.
sum_x += x[i]; sum_y += 
y[i]; sum_xy += x[i] * y[i]; 
sum_x_squared += x[i] * 
x[i];
}
*slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x_squared - sum_x * 
sum_x);
*y_intercept = (sum_y - *slope * sum_x) / n;
}
int main() { int N, i; printf("Enter the number 
of data points: "); scanf("%d", &N);
double slope, y_intercept, x[N], 
y[N]; printf("Enter the value of x: "); 
for(i = 0; i < N; i++){
scanf("%lf", &x[i]);
}
printf("Enter the value of y: "); 
for(i = 0; i < N; i++){
scanf("%lf", &y[i]);
}
linear_regression(x, y, N, &slope, &y_intercept); printf("Linear regression 
equation: y = %.2fx + %.2f\n", slope, y_intercept); return 0;
}
